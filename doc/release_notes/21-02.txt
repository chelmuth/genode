

              ===============================================
              Release notes for the Genode OS Framework 21.02
              ===============================================

                               Genode Labs



; intro

;@nfeske


Pluggable network device drivers
################################

The results of our approach to
[https://genode.org/documentation/release-notes/20.08#The_GUI_stack__restacked - pluggable framebuffer and input drivers]
encouraged us to take on the third major driver category, namely networking
drivers, which subsumes not only Ethernet drivers but also wireless networking
drivers and mobile baseband drivers. The latter two are of course particularly
interesting for mobile communication devices.

Similarly to the story given above for the framebuffer and input drivers,
Genode's network drivers used to play the roles of NIC servers, providing a
network-interface service to network applications. As a consequence, the
lifetime of a network application was always bound to the lifetime of the
underlying NIC driver. An unfortunate fact in, for instance, the event of a
crash in the usually large driver code base but also when it comes to
the intentional unplugging or exchange of drivers.

[image layered_nic_multi_app_risk]

However, in most scenarios, networking applications do not operate directly on
a network interface because this would prevent the use of the network interface
by more than one application at a time. Instead, there is usually a NIC
multiplexing component in-between the driver and one or multiple applications.
In most contemporary scenarios this is the NIC router that acts as NIC client
towards the driver and as NIC server towards the applications.

Thus, we contemplated the idea of letting the NIC driver operate as NIC client
of the NIC router instead as this would decouple the application from the
drivers lifetime while the driver's special role would be modeled solely by a
routing policy. However, even though the data channel of the NIC interface is
bi-directional, we realized that the reversal of the role of the driver does
not only entail the communication of network payload but also propagation of
the link state and the MAC address. This prompted us to introduce a new Genode
session type called "Uplink" that precisely models the NIC-driver-as-client
scenario.

[image nic_router_services]

In a nutshell, an Uplink session is almost the same as a NIC session with only
three minor differences. First, the MAC address is given by the client (the
driver) through an argument in the session request. Second, the roles of the TX
and RX packet streams are interchanged compared to a NIC session. I.e., the
_client_ transmits via TX and receives through RX while at the server side it's
vice-versa. And third - as a mere interface optimization - the link state of an
Uplink session is always "up". The session is requested by the client (the
driver) only in the event of a "link-up" edge. Analogously, whenever the link
goes "down", the client closes the session again.

With this new session interface in place, the NIC router becomes the only
long-running component in the scenario. It provides both a NIC and an Uplink
session interface. The NIC session interface is used by network applications.
The Uplink session interface is used by drivers. Inside the router, Uplinks
sessions are treated the same as NIC sessions. Therefore, we decided that the
well known <policy> tags in the configuration are now simply applied to both
session types. This means, that each <uplink> tag that connected a driver in a
router configuration can now be replaced through a <policy> tag with a label
attribute that matches the drivers session request.

[image nic_uplink_multi_app]

We divided the process for this architectural change into the following
autonomous steps:

# Introduce the Uplink session and Uplink-session support in the NIC router.
# Let NIC drivers support both modes, "NIC session server" and "Uplink session
  client" depending on a new _transitional_ <config>-tag attribute 'mode'.
  This attribute is optional and has two possible values, 'uplink_client'
  and 'nic_server', of which it defaults to the latter.
# Adapt all network scenarios in the basic Genode repositories to use NIC
  drivers only with '<config mode="uplink_client">'.
# Remove support for the "NIC session server" mode from all NIC drivers and
  with it also the transitional 'mode' attribute.

All steps except the last one are completed by now. The transitional 'mode'
attribute and the "NIC session server" mode will remain available in all NIC
drivers until the next Genode release in order to give others the opportunity
to gracefully adapt their NIC drivers and network scenarios to the change.


LTE modem stack
###############

With the current release Genode adds LTE broadband modem support for packet data
connections. This way it becomes possible to browse the internet using the SIM
card of your broadband service provider. For a description of the protocols and
the general terminology when talking about LTE modems our
[http://genodians.org/ssumpf/2020-12-04-mbim - LTE modem support for Genode]
Genodians article is a good starting point.

From the device side, LTE modems register themselves as USB devices at the USB
host controller. The speciality is that a modem offers two devices. First, an USB
network interface (like NCM or ECM) and second, a
[https://www.usb.org/document-library/class-definitions-communication-devices-12 - Wireless Mobile Communication Device]
which is a challenge/response control channel to the modem and used to configure
the device. For the actual communication through the control channel there exist two
binary protocols: Namely, Mobile Broadband Interface Model (MBIM) and Qualcomm
Mobile Station Interface (QMI). While the former is an USB standard, QMI is a
proprietary Qualcomm protocol. Therefore, we choose a modem that supports the
MBIM standard for Genode.

USB modem support
=================

In order to enable modem communication we added the Linux USB modem driver for
MBIM to our _dde_linux_ device driver environment. This driver implements the
NCM and WDM interfaces for the modem and provides a network Uplink session for
the NCM network interface and a Terminal session for the WDM interface (image
[lte_mbim]).

MBIM protocol
=============

MIBM is a binary protocol that is, for example, implemented by
[https://www.freedesktop.org/wiki/Software/libmbim/ - libmbim]. Therefore, we
ported _libmbim_ to Genode. Since it requires _glib_ we had to enable features
and improve our _glib_ support on Genode. _libmbim_ offers MBIM commands only,
to actually trigger modem-communication the _mbimcli_ tool is required. We
ported _mbimcli_ and changed it's front-end to trigger a modem packet-connection
sequence via _libmbim_ through the Terminal session of the USB modem driver.
During this sequence the SIM card is unlocked through the PIN, the packet
service is attached, and connection information (e.g., IP, gateway, DNS server)
is retrieved. The connection data is then used by _mbimcli_ to configure the
uplink of Genode's NIC router, which in turn Genode network applications can
connect to. The holistic view is shown in image [lte_mbim].


Base framework and OS-level infrastructure
##########################################

NIC router
==========

The NIC router received two very practical features, the consideration of
multiple DNS server entries on DHCP and an ARP-less mode for domains.

The latter was motivated by the fresh support for LTE modems (see section
[LTE modem stack]). An LTE modem normally doesn't respond to ARP, so, when
using it as uplink for the NIC router, the corresponding domain can't request
IP-to-MAC-address resolutions as usual. This is addressed through the new
optional attribute 'use_arp' in <domain> tags of the NIC router configuration.
By default it is set to 'yes' which yields the same behavior as in the past.

However, when set to 'no' for a domain, this domain will prevent sending ARP
requests in general. This leaves the question how to determine the destination
MAC address for a packet that shall be sent at this domain when only the
destination IP address is known. This is solved by the router by simply using
the source MAC address also as destination MAC address, an approach that we
could observe also in other IP stacks and that worked just fine in our tests.

The ARP-less domain mode is demonstrated through the run script
_repos/os/run/nic_router_disable_arp.run_.

The consideration of multiple DNS-server entries on DHCP comes in two parts.
First, when acting as DHCP client at a domain, the router will now parse all
option 6 entries in DHCP ACK replies from the server and memorize them as part
of the resulting IP config of the domain. These entries will then also be
reported if '<report config="yes"/>' is set in the routers config. A router
report with multiple DNS server entries will look like this:

! <state>
!   <domain name="uplink_1" ipv4="10.0.0.3/24" gw="10.0.0.1">
!     <dns ip="10.0.0.2"/>
!     <dns ip="1.1.1.1"/>
!     <dns ip="8.8.8.8"/>
!     ...
!   </domain>
!   <domain name="uplink_2" ipv4="168.192.0.200/24" gw="168.192.0.1">
!     <dns ip="168.192.0.10"/>
!     <dns ip="168.192.0.8"/>
!     ...
!   </domain>
!   ...
! </state>

On the other hand, when acting as DHCP server at a domain, one has two
options. Option 1 is to configure the DHCP server to fetch DNS server entries
automatically from another domain:

! <domain name="downlink" interface="10.0.1.1/24">
!   <dhcp-server dns_server_from="uplink_1" .../>
! </domain>

In this case, the router will now reflect not only one but all DNS server
entries from the source domain ("uplink") through the DHCP replies sent at the
destination domain ("downlink") without changing the entry order. This approach
is demonstrated through the new _repos/os/run/nic_router_dhcp_unmanaged.run_
run script.

Option 2 is to configure the DNS server entries manually at the DHCP
server:

! <domain name="downlink" interface="10.0.1.1/24">
!   <dhcp-server ...>
!     <dns-server ip="10.0.0.2"/>
!     <dns-server ip="1.1.1.1"/>
!     <dns-server ip="8.8.8.8"/>
!   </dhcp-server>
! </domain>

The order in which the <dns-server> tags occure also determines the order of
option 6 entries in the replies of the DHCP server. Besides its use for static
DNS server configurations, this option can also be used for more sophisticated
forwarding of DNS server entries through a separate management component. The
management component could listen to the reported IP config of the source
domains, apply custom policies like address filters to the result, and
re-configure the DHCP servers of the destination domains accordingly. This
approach is demonstrated in the new _repos/os/run/nic_router_dhcp_managed.run_
run script.

Please note that thhe former 'dns_server' attribute of the <dhcp-server> tag
is no longer considered by the router as the new <dns-server> tag replaces it.
Thus, you might want to adapt your NIC router scenarios accordingly.


VFS support for named pipes
===========================

The VFS-pipe plugin received new support for named pipes. The main motivation was to
easily stream data from pure Genode components to libc components via
file-system sessions that can be attached to stdin, stdout, and stderr. This
feature further makes it possible to pipe several components together,
similarly to how it is done on Unix. Additionally, the thread synchronization
has been improved so that large data chunks can be transferred without
blocking.

A named pipe can be created by adding a '<fifo>' sub node to the '<pipe>' node
of the VFS:

! <vfs>
!   <pipe>
!     <fifo name="upstream"/>
!   </pipe>
!   ...
! </vfs>

Each pipe is exposed as a set of pseudo files.

! /upstream
! /.upstream/in/in
! /.upstream/out/out

The _/upstream_ pseudo file can be opened either as read-only or write-only
file. It allows for the access of both ends of the pipe. In contrast, each of
the pseudo files _/.upstream/in/in_ and _/.upstream/out/out_ represents only
one end of the pipe, which can be subjected to an individual directory-based
access-control policy.


Terminal
========

While
[https://genode.org/documentation/release-notes/20.08#The_GUI_stack__restacked - revising the GUI stack]
in Genode 20.08, we largely abolished the use of the framebuffer and input
session interfaces. The graphical terminal, however, still relied on those
interfaces instead of the GUI session. In practice, there was always a gui_fb
component needed as an intermediate between the terminal and the GUI server.
To complete the GUI-stack transition, we changed the terminal to use the GUI
session directly and adjusted all current scenarios that use the terminal.

One useful feature of the gui_fb component was the definition of an initial
window size. This enabled packages such as Sculpt's system shell to present
terminal windows with a reasonable default size smaller than the entire
screen.
To accommodate this special case, the initial terminal size can now be
explicitly configured in the terminal configuration.

! <config>
!   <initial width="800" height="600"/>
!   ...
! </config>

While we were at it, we also enhanced the terminal with the ability to
dynamically respond to font changes. So the adjustment of the global font
settings in Sculpt OS takes immediate effect on all terminal windows.


OpenSSL 1.1.1i, curl 7.70.0
===========================

;@chelmuth

commit 7d1f158d6836ed8e52e0feecc46aa455b1ae1841
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Wed Mar 18 16:27:28 2020 +0100

    Update OpenSSL to version 1.1.1i
    
    Note, OpenSSL now comes as one combined depot archive *openssl* that
    replaces the former *libssl* and *libcrypto* archives. The libraries are
    still separate binaries for compatibility with legacy software.
    
    Issue #3773

commit 61a530a485241b88a049efadd0de42f82647c918
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Thu Feb 18 14:55:31 2021 +0100

    squash "openssl: do not depend on ARM CPU probing" (COMMIT MESSAGE)
    
    openssl: do not depend on ARM CPU probing
    
    With this commit libcrypto does not use ARM NEON extension as long as
    SPECS includes "neon". arm_v7a does declare "neon" per default while
    arm_v8a does.

commit b462b1e658f78a6d93d8896d9dcdf2839812cdbd
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Wed Jun 3 13:57:52 2020 +0200

    Update curl to version 7.70.0
    
    Issue #3773


Virtualization
##############

VirtualBox 6.1.14
=================

;@chelmuth

commit b25fc1e58a58c1c7d4a130acec73211a656766a5
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Fri Dec 18 14:08:06 2020 +0100

    base: refactor VM/vCPU API
    
    Issue #3554


VirtualBox 5
============

In this release we extended our VirtualBox port and made using USB
pass-through more robust.

So far, we most prominently use VirtualBox on Intel systems that feature
VT-x. This release enables support for also running 64bit guests on AMD
systems with SVM.

When it comes to USB pass-through support we rely on the xHCI device-model
ported from Qemu. With this release we updated the contrib sources to
version 5.2.0 and the used exposed device is changed to QEMU xHCI. Due to
this change older guests OSes, namely Windows 7, that relied on the NEC
xHCI device will no longer work.
The 'Qemu::Controller' interface was extended by an 'info' method, which
returns the vendor and product ID. This allows for removing the hard-coded
values in the VirtualBox glue code.

Due to the update it becomes possible to use USB devices using isochronous
transfers, in particular audio devices, with Windows 10 guests. For now
we focused on USB-Audio-Class v1 devices using adaptive synchronisation.

On one hand, the handling of isochronous OUT transfers in our host connection
is now more in line with the original host implementation in Qemu and batches
multiple packets and queues transfers. Having transfers in-flight helps to
smoothen out playback in case other components utilize the CPU.
On the other hand, the number of IN requests queued is increased to 32 while
the number of packets per request is decreased to 1. Linux as well as Windows
guests want queue to a varying number of transfers, where each transfer only
covers one packet (iso frame). We obtained the best results by following
that behaviour rather than queuing multiple iso frames per request.

Furthermore we changed the way the DMA buffers are accessed. The device-model
wants to access the DMA buffers residing in the guest-physical memory by
mapping them locally to VMM address-space.
When we originally implemented the glue-code we implicitly relied on the mapped
memory ranges being continous. However, as it turned out, that is not always
the case. Although it appears that those mappings are continous, after all we
got away using the mechanism for years with Linux guests without any problems,
writing larger files to an USB stick with a Windows 10 guest led to data
corruption because the wrong data was copied. For the time being, rather than
dealing with the mappings directly we opted for introducing a bounce buffer
that is used to copy to and copy from the guest physical memory. It uses a
simple helper API provided by VirtualBox for reading and write the memory and
leaves dealing with the mappings entirely up to the VMM behind the scenes.


VirtIO block devices for virtual machines on ARM
================================================

With release 20.02 the first VirtIO device models entered Genode's virtual
machine monitor for ARM. They enabled a virtual machine to access network and
terminal services. This time the VMM got extended with a block device model,
which again is compliant to the VirtIO 1.1 specification. Moreover, the generic
model implementation, which is common to all VirtIO devices, got polished fairly.

The new block device model is not configureable yet. By now, the VMM is
hard-coded to provide exactly one block device. Consequently, one route to a
Block service needs to be provided to the VMM component.

Execution of the test run-script in `repos/os/run/vmm_arm.run` shows
the new VirtIO block device in action.


Device drivers
##############

Power-gating of PCI devices on x86
==================================

PCI devices have several PCI capabilities, which describe the feature set
they support, as defined by the PCI specification. The platform driver, which
is the gatekeeper on Genode, got extended to power on and off devices, if the
PCI power capability is supported. On powering on, a device reset
is issued if supported by the PCI device. During release of a driver from a
device, the DMA memory assigned and thereby accessible to a device are
flushed from the IO-MMU TLB to avoid further access afterwards.

Additionally, the platform driver now supports to react on configuration
changes. Special care must be taken, if the configuration of a running device
driver changes. If the configuration re-evaluation yields that a driver is not
permitted to use an already assigned PCI device anymore, the Platform session
will be closed forcefully and make the device inaccessible to the driver.

The extended features of the platform driver supplements the previous work of
restarting respectively replacing an running graphic driver. The driver
manager, as used by Sculpt, uses Genode heartbeat monitoring to check for the
liveness of the Intel Frambuffer driver and restarts it by need. Restarting
involves to close the Platform session, thereby powering off the Intel device
and reoping the Platform session, thereby powerering it on and resetting the
Intel device into a functional state.


USB drivers
===========

Additional HID devices
~~~~~~~~~~~~~~~~~~~~~~

;@chelmuth

commit 2a659cb75029f3a3d7cc6a1b2d49281d84c3dc47
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Fri Sep 14 16:55:20 2018 +0200

    usb_hid: support for Holtek-based mice fixups
    
    This enables USB mice based on the Holtek chipsets, which need USB
    descriptor fixups. An example mouse is the Sharkoon Drakonia.
    
    Issue #3953

commit 496dc5508f798324ca24a7e8ea4ffdb4bd31fa22
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Fri Sep 14 16:58:35 2018 +0200

    usb_hid: support for Apple HID devices
    
    Issue #3953


USB robustness
~~~~~~~~~~~~~~

We improved the robustness of the USB HID driver with regard to device
reconnection, as well as the robustness of the DWC OTG host driver for
the Raspberry Pi when used with HID devices.


Isochronous transfers
~~~~~~~~~~~~~~~~~~~~~

While looking more closely into supporting isochronous transfers,
driven by the USB pass-through use-case, we encountered shortcomings
in the current implementation in the USB host-controller driver
when dealing with IN transfers containing multiple iso frames.

Since the host driver uses the original offsets into the DMA buffer
when filling in the data of the transfer, even if any of the iso
frames contains less data than requested, we have to scan the whole
transfer buffer. Additionally, we have to reflect the actual length
of the captured data so that the client can distinguish short-reads.

For the time being, we always copy the whole buffer into the packet
stream and update the newly added 'actual_packet_size' member in the
packet descriptor. With those information at hand the client can iterate
through the buffer.

Exposing the buffer in such a way is error-prone and we therefore plan
on adding an abstraction to make dealing with isochronous safer and more
convient. This, however, is post-poned until we get a better grasp at
the requirements.


Platforms
#########

Pine-A64-LTS single board computer
==================================

Our this year's [https://genode.org/about/road-map - road map] envisions
the use of Genode on the Pinephone by the end of the year. As a first stepping
stone, the current release adds basic board support for the
[https://pine64.com/product-category/pine-a64-ltslong-term-supply/ - Pine-A64-LTS]
single-board computer. We take this line of work as a welcome opportunity to
thoroughly document the porting process. You can find the work explained in
great detail in the following article series.

# [https://genodians.org/nfeske/2020-12-10-pine-fun-warmup - Warming up for some Pine fun]
# [https://genodians.org/nfeske/2020-12-17-pine-fun-serial - Bare-metal serial output]
# [https://genodians.org/nfeske/2021-01-28-pine-fun-kernel-skeleton - Kernel skeleton]
# [https://genodians.org/nfeske/2021-02-11-pine-fun-debugging - How did we come here?]
# [https://genodians.org/nfeske/2021-02-18-pine-fun-user-land - Excursion to the user land]


RISC-V
======

RISC-V development has been on the hold at Genode Labs for a while, but with the
current release this has changed. One of the main goals we had for a long time
is to use Qemu instead of the Spike emulator for our test infrastructure, since
every other platform runs on Qemu, Spike causes additional overhead at Genode
Labs.

In another project we had already bumped Genode's RISC-V support from privileged
ISA specification 1.9.1 to 1.10. This came in handy because our current Qemu
testing version (4.2.1) does not support ISA 1.9.1 any more, but only 1.10 and
1.11. This way we were able to update Genode's generic RISC-V implementation
quickly, remove the _spike_ board and add a new _riscv_qemu_ board to our
_base_hw_ kernel implementation.

As another nice side effect, Qemu ships it's own OpenSBI machine binary which
implements the machine mode and SBI calls. It can be enabled through the "-bios"
command line option. With a machine mode for ISA 1.10 in place, we were able
remove the old [https://github.com/ssumpf/bbl-lite - BBL] machine mode
implementation from Genode.
; TODO: For more information on this topic please refer to our
; [http://genodians.org/ssumpf/2020-02-22-riscv - Genodians] article.

In order to improve development speed, we were able to reduce the link time for
_core_ and it's debugging variant from about 50 to 5 seconds.  Additionally we
fixed long standing link errors that were caused by mixing up soft float and
hard float objects as well as misconfigured linker scripts.


Removal of Muen separation kernel support
=========================================

Since
[https://genode.org/documentation/release-notes/15.08#Genode_on_top_of_the_Muen_Separation_Kernel - version 15.08],
Genode supported the use of the [https://muen.sk - Muen] separation kernel as
underlying platform. The driving force behind the original development was the
joyful collaboration with the Muen developers and the prospect for products
that combine the rigidity of a separation kernel with the dynamic workloads
enabled by Genode.

However, over the past 5 years, this potential synergy remained untapped.
In hindsight, the stacking of one microkernel-based system onto another
microkernel-based system is a tough sell. Hosting dynamic workloads in a Linux
VM atop Muen is certainly more relatable to Muen users. Vice versa, for Genode
users, Genode on bare hardware is less complex and more flexible than using
the framework atop a separation kernel.

Without adoption of the joint platform, neither of both teams can justify the
ongoing effort needed for the continued maintenance of Genode on Muen. Hence,
we [https://github.com/genodelabs/genode/issues/3995 - concluded] to remove
Muen as an officially supported platform.


Build system and tools
######################

Streamlined distinction of boards by build and run tools
========================================================

In
[https://genode.org/documentation/release-notes/20.05#Board_support_outside_the_Genode_main_repository - Genode 20.05], 
we introduced the principle ability to decouple board-support packages from
the project's main repository. We thereby want to enable developers outside
the Genode core team to porting Genode to diverse hardware platforms.
With the current release, we further refined the structure of the code base and
the tooling to largely eliminate remaining points of friction when hosting
board support in external repositories.

We ultimately removed the use of board-specific SPEC values throughout the
build system and run scripts. SPEC values are now solely used to refer to
aspects of an instruction-set architecture, e.g., x86, 64bit, arm_v8a.
In run scripts, the new convenience function 'have_board' can be used to
distinguish the behavior of run scripts depending on the targeted board now.
It replaces all former uses of 'have_spec <board>'. The long deprecated
option of the _create_builddir_ tool to create board-specific build directories
has been removed.

To simplify the hosting of board support in separate source-code repositories,
board-specific properties have moved from run-tool scripts to the new notion
of *board property directories*. Such directories named
_<repo>/board/<board>/_ contain files with board-specific properties.
In particular, the 'image_link_address' file contains the physical
link address of the system image, and the 'arch' file contains the CPU
architecture of the SoC. The run tool picks up this information from the
board-property files.

Furthermore, the *packaging* of the board-specific base-hw kernel has
become more formalized by leveraging the board-property directories.
This makes the packaging vastly simpler.
Regardless of where the board-support
is hosted, the content.mk file becomes as simple as:

! include $(GENODE_DIR)/repos/base-hw/recipes/src/base-hw_content.inc

The board name is automatically inferred from the path of the src recipe. The
architecture is determined from _board/<name>/arch_ files. The attempt to
build a base-hw-<board> binary archive for the wrong architecture is now
gracefully handled by skipping all targets (using the REQUIRES mechanism).

Besides the improved convenience, the resulting depot archives
have become much closer tailored to the actual board by omitting files for
architectures that are not used by the board. E.g., the src/base-hw-pc
archive does not contain any ARM-related content.


Compiler cache
==============

The [https://ccache.dev - ccache] tool is a fantastic way to accelerate the
developer workflow when repeatedly building software. Since ccache is -
strictly speaking - orthogonal to the build system, configuring the Genode
build system for the use of ccache was left to each developer.

Setting up ccache is not straight-forward though. One must manually create
hooks (symlinks shadowing the compiler executables), tweaking the PATH
environment variable, and customizing the CROSS_DEV_PREFIX in
_etc/tools.conf_. In short, only seasoned developers jump through those hoops.
Many others may miss out on the joys of ccache.

With the current release, the build-system front end makes ccache easily
available by enabling a simple option in the _etc/build.conf_ file:

! CCACHE := yes

